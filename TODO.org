
* Design considerations (thanks, Discord Quake Remastered!)

 - quake directory structure review: https://www.slipseer.com/index.php?threads/understanding-your-quake-directory-installing-custom-content.174/

 - compilers

   - the majority of developers use FTEQCC, and the dialect that comes with it (see
     https://www.fteqcc.org/dl/fteqcc_manual.txt)

   - majority of modes use Vanilla QuakeC but worth working on dialects as well

   - gmqcc (https://graphitemaster.github.io/gmqcc/) - a compiler that tries to be modern
     in its approaches, has tests, it strict with standards, etc

   - the original qcc: https://github.com/id-Software/Quake-Tools/tree/master/qcc

     - Quake-Tools/qcc/qcc.h comments have the closest thing to a grammar of Vanilla C.
       The language is simple enough to make it possible to put together something like
       eBNF quickly

 - default community tools: editors, vscode with plugins

 - Collection of resources: https://github.com/dumptruckDS/awesome-quake

 - QuakeC code:

   - Quake Rerelease: https://github.com/id-Software/quake-rerelease-qc

   - Arcane Dimensions mod: https://github.com/SimsOCallaghan/ArcaneDimensions

   - 2048 mod: https://github.com/jhspetersson/q2048

   - dev kit: https://developer.vera-visions.com/ (https://github.com/VeraVisions/nuclide)

   - dev kit: progs_dump (https://github.com/progs-dump-dev/progs_dump)

 - maintained engines: FTE, Quakespams, Ironwail, vkquake

   - engine overview: https://www.slipseer.com/index.php?threads/quake-engines-source-ports-a-beginners-guide.11/


* Major compilers

** qcc

- The compiler goes through files listed in .src one by one while filling global data
  structures.

- there 67 ops supported by the VM

- Order of files included is important because of declarations/defintions.

- The resulting data structures are then dumped into a single file

- There are bits and pieces of non-QuakeC things in files, mostly ignored

** fteqcc

- the compiler is still based on the same manual RD parser/lexer as qcc

- there many more language features and target VMs support

- compilation is abstracted into a library (qclib)

- qcc as a library is utilised in fteqccui, qcctui and elsewhere (the engine itself? code
  reloading? game console? crazy stuff)

** gmqcc

- clean slate reimplementation of the compiler in a C/C++ hybrid, mostly leaning towards
  the C style

- the compiler is quite advanced. Smells like SSA IR as one of the stages!

- does support language standards (qcc, fteqcc, gbqcc - the default)

- it seems that codegen is limited to a more or less standard QuakeC vm (67 ops) +
  Darkplaces stuff but I not sure. Is all of FTE supported?

* The Original Quake Internals

** Original Quake / qcc progs.data

The binary file format resulting from the QuakeC compiler source code is structured as
follows:

- progs struct: A metadata header (dprograms_t) describing offsets and sizes for various
  data sections. This struct is filled at the end of the process.

- strings: A block of null-terminated strings used in the program.

- statements: A block of dstatement_t structures representing bytecode instructions.

- functions: A block of dfunction_t structures providing information about each function in the program.

- global definitions: A block of ddef_t structures representing global variable definitions.

- field definitions: A block of ddef_t structures representing definitions of entity
  fields.

- globals: A block of global values (4-byte values).

Data types in the file:

- dprograms_t: Metadata about the compiled program, such as version, CRC, and offsets/sizes of the sections.

- ddef_t: Definition of a variable or a field, including type, offset, and string name.

- dstatement_t: An instruction for the Quake virtual machine, containing operation code and operands.

- dfunction_t: Information about a function, including first statement number, parameter details, and string name/file.

All multi-byte values are stored in little-endian format. After writing all sections, the
header is updated with the correct information and written at the beginning of the file.

* Further work and ideas

  - [X] local completion

  - [X] basic syntax highlighting for common language elements

  - [X] imenu support

    - [X] qc style functions

    - [X] global variables

    - [X] fields

    - [X] methods

  - [-] unit testing

    - [X] find-definitions

    - [X] which-func

    - [X] eldoc

    - [X] rel path, project root

    - [-] font-lock

      - [X] functions/funparams

      - [X] variables

      - [X] keywords

      - [ ] literals, especially vectors

        - something non-trivial going on because of how cc-mode expects things to be,
          can't just use modify-syntax-entry

        - removing cc-mode inheritance removes a lot of niceness (e.g. beginning-of-defun and
          indentation)

        - just use font-lock to find these? what about navigation?

  - [X] which-func support

  - [X] syntax highlighting

    - [X] comments (both cpp/c style)

    - [X] qc functions names

    - [X] model pragmas

    - [X] builtins

    - [X] variable names

      - [X] global

      - [X] fields

      - [X] formal parameters

      - [X] multiple variable definitions per line

      - [X] methods

      - [X] local definition

      - [X] frame functions

  - [X] defcustom for key variables/parameters

  - [X] packaging tool - cask

  - [X] quakec-mode-map

  - [-] xref

    - [X] local definitions

    - [ ] wider definition search (hybrid with grep-like or something?)

    - [ ] good example as well: js-mode (derived from espresso-mode i used to use),
      especially the way js-find-symbol works with all known symbols

    - [ ] https://github.com/js-emacs/xref-js2/blob/master/xref-js2.el - interesting
      hybrid ast/ag global symbol search

    - [ ] similar to js-mode js2-mode does symbol search in all open buffers

  - [-] compilation support for popular compilers

    - consult the rust-mode code for good approach to formatting

    - [X] FTEQCC

    - [X] gmqcc

    - [X] suggest a default compile command

    - [X] use the root finding function to always kick off compilation in the project root

      see the discussion: https://stackoverflow.com/questions/9037833/how-to-set-the-default-directory-of-compilation-in-emacs

    - [X] provide a specilised compilation function

    - [X] eval-after-load when injecting compilation-mode regexps

    - [ ] qcc

    - [ ] others?

  - [-] flymake

    - [X] FTEQCC

    - [X] GMQCC

    - [ ] qcc

  - [X] extract specialised faces to be used for highlighting

  - [-] Eldoc

    - [X] local definitions

    - [ ] global definition based on progs.src or something

  - [ ] see coffee-mode for how to provide customize interfaces, compilation commands,
    setup hideshow minor mode, etc

  - [ ] advanced support

    - [ ] full fteqcc dialect

      - [ ] raw language

      - [ ] preprocessing?

    - [ ] full gmqcc dialect

      - [ ] language

      - [ ] preprocessing?

  - [ ] setup Elsa

  - [ ] src file support? generic mode?

  - [ ] reuse definition cache between xref and eldoc (and imenu?)

  - [ ] hideshow

  - [ ] publish the package

  - [ ] c-style functions? better dialect support?

  - [ ] enforce emacs lisp coding conventions

    - [ ] write a package release checklist

    - [ ] checkdoc

    - [ ] package-lint

    - [ ] README update

    - [ ] emacs lisp conventions for variables and constants?

    - [ ] eval-when-compile for rx

  - [ ] global completion
